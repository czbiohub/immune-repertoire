---
title: "Memory B Cell Transcriptome Notebook"
output: html_notebook
---

Specify the tissue of interest, run the boilerplate code which sets up the functions and environment, load the tissue object.

```{r}
library(useful)
library(Seurat)
suppressMessages(library(dplyr))
library(Matrix)
library(ontologyIndex)
suppressMessages(library(tidyverse))
library(here)
library(readxl)
```

Read in the raw counts matrix
```{r}
filename = here('raw_data', '180416_NB501961_0098_AHLNCFBGX5.csv')
raw.data = read.csv(filename, row.names=1)
head(raw.data)
```

```{r}
corner(raw.data, corner='topright')
```


Convert sample ids to well numbers alone and reassign column names

```{r}
# Remove "Undetermined" column (last column)
raw.data.no.undetermined = raw.data[,0:(length(colnames(raw.data))-1)]


sample.ids = colnames(raw.data.no.undetermined)
well.numbers = sapply(sample.ids, function (x) {strsplit(x, '_')[[1]][1]})
sample.numbers = sapply(sample.ids, function (x) {strsplit(x, '_')[[1]][2]})

colnames(raw.data.no.undetermined) = well.numbers
corner(raw.data.no.undetermined, corner='topright')
corner(raw.data.no.undetermined)
```

Read Scaligner data

```{r}
filename = here('raw_data', '3.28.18_96VH.Scaligner-20180508-212314.xlsx')
scaligner = read_excel(filename)
head(scaligner)
```

Create sample metadata

```{r}
colnames(scaligner)
```


Filter scaligner data only to wells that are in the raw data matrix
 
```{r}
scaligner.in.data = scaligner %>% filter(X__1 %in% well.numbers)
dim(scaligner.in.data)
```


```{r}
# Get reordered indices of where the well numbers are so they align with the rows in scaligner
ind = match(scaligner.in.data$X__1, well.numbers)

meta.data = data.frame(vh_gene=scaligner.in.data$VH, jh_gene=scaligner.in.data$JH,
                       row.names=scaligner.in.data$X__1, sample_numbers=sample.numbers[ind])
head(meta.data)
```



```{r}
# Find ERCC's, compute the percent ERCC, and drop them from the raw data.
erccs <- grep(pattern = "^ERCC-", x = rownames(x = raw.data.no.undetermined), value = TRUE)
percent.ercc <- Matrix::colSums(raw.data[erccs, ])/Matrix::colSums(raw.data.no.undetermined)
ercc.index <- grep(pattern = "^ERCC-", x = rownames(x = raw.data.no.undetermined), value = FALSE)
raw.data.no.undetermined <- raw.data.no.undetermined[-ercc.index,]

# Create the Seurat object with all the data
tiss <- CreateSeuratObject(raw.data = raw.data.no.undetermined, 
                           project = 'memory_b_transcriptome_h1n1_influenza')
tiss <- AddMetaData(object = tiss, meta.data)
tiss <- AddMetaData(object = tiss, percent.ercc, col.name = "percent.ercc")

# Change default name for sums of counts from nUMI to nReads
colnames(tiss@meta.data)[colnames(tiss@meta.data) == 'nUMI'] <- 'nReads'

# Create metadata columns for cell_ontology_class
tiss@meta.data[,'free_annotation'] <- NA
tiss@meta.data[,'cell_ontology_class'] <- NA

#Calculate percent ribosomal genes.

ribo.genes <- grep(pattern = "^Rp[sl][[:digit:]]", x = rownames(x = tiss@data), value = TRUE)
percent.ribo <- Matrix::colSums(tiss@raw.data[ribo.genes, ])/Matrix::colSums(tiss@raw.data)
tiss <- AddMetaData(object = tiss, metadata = percent.ribo, col.name = "percent.ribo")

tiss <- FilterCells(object = tiss, subset.names = c("nGene", "nReads"), 
                    low.thresholds = c(500, 5e4))
```



Run PCA and ICA
```{r}
# Use scale of transcripts per million (1e6) for smartseq2 data
scale = 1e6
tiss <- NormalizeData(object = tiss, scale.factor = scale)
tiss <- ScaleData(object = tiss)
tiss <- FindVariableGenes(object = tiss, do.plot = TRUE, x.high.cutoff = Inf, y.cutoff = 0.5)

# Run Principal component analysis
tiss <- RunPCA(object = tiss, do.print = FALSE)
tiss <- ProjectPCA(object = tiss, do.print = FALSE)

# Run Independent component analysis
tiss = RunICA(tiss)
tiss = ProjectDim(tiss, reduction.type = 'ica', do.print=FALSE)
```

## Look at cell cycle effect and assign cell cycle state

```{r}
filename = here('raw_data', 'cell_cycle_vignette_files', 'regev_lab_cell_cycle_genes.txt')
cc.genes <- readLines(con =filename)

# We can segregate this list into markers of G2/M phase and markers of S
# phase
s.genes <- cc.genes[1:43]
g2m.genes <- cc.genes[44:97]
```

Assign cell cycle scores

```{r}
tiss <- CellCycleScoring(object = tiss, s.genes = s.genes, g2m.genes = g2m.genes, 
    set.ident = TRUE)

# view cell cycle scores and phase assignments
corner(tiss@meta.data, corner='topright')
```

```{r}
PCAPlot(tiss)
ICAPlot(tiss)
```

They're all randomly mixed together, meaning that cell cycle is not a dominant difference between the cells.

## Show PCA and ICA plots
```{r}
PCAPlot(tiss, do.hover=TRUE)
ICAPlot(tiss, do.hover=TRUE)
```
What's up with C9 and D5? They're the outliers here
```{r}
tiss@meta.data[c('C9', 'D5', "C10", "D4"), ]
```
Ah They have way fewer reads than everyone else

### Histogram of number of genes and number of reads

```{r}
ggplot(data=tiss@meta.data, aes(x=nReads)) + geom_histogram()
ggplot(data=tiss@meta.data, aes(x=nGene)) + geom_histogram()
```

## Filter out genes with too few reads
```{r}
tiss <- FilterCells(object = tiss, subset.names = c("nGene", "nReads"),
                    low.thresholds = c(1000, 1e7), high.thresholds = c(4000, 1e8))
```


## Renormalize on filtered data

Run PCA and ICA
```{r}
# Use scale of transcripts per million (1e6) for smartseq2 data
scale = 1e6
tiss <- NormalizeData(object = tiss, scale.factor = scale)
tiss <- ScaleData(object = tiss)
tiss <- FindVariableGenes(object = tiss, do.plot = TRUE, x.high.cutoff = Inf, y.cutoff = 0.5)

# Run Principal component analysis
tiss <- RunPCA(object = tiss, do.print = FALSE)
tiss <- ProjectPCA(object = tiss, do.print = FALSE)

# Run Independent component analysis
tiss = RunICA(tiss)
tiss = ProjectDim(tiss, reduction.type = 'ica', do.print=FALSE)
```
Make sure there's no weird outliers

```{r}
PCAPlot(tiss, do.hover=TRUE)
ICAPlot(tiss, do.hover=TRUE)
```

Visualize top genes in principal components

```{r, echo=FALSE, fig.height=8, fig.width=8}
PCHeatmap(object = tiss, pc.use = 1:6, do.balanced = TRUE, label.columns = FALSE, num.genes = 8)
```

Later on (in FindClusters and TSNE) you will pick a number of principal components to use. This has the effect of keeping the major directions of variation in the data and, ideally, supressing noise. There is no correct answer to the number to use, but a decent rule of thumb is to go until the plot plateaus.

```{r}
PCElbowPlot(object = tiss)
```

Choose the number of principal components to use.
```{r}
# Set number of principal components. 
n.pcs = 4
```


The clustering is performed based on a nearest neighbors graph. Cells that have similar expression will be joined together. The Louvain algorithm looks for groups of cells with high modularity--more connections within the group than between groups. The resolution parameter determines the scale...higher resolution will give more clusters, lower resolution will give fewer.

For the top-level clustering, aim to under-cluster instead of over-cluster. It will be easy to subset groups and further analyze them below.


To visualize, we make a TSNE plot

```{r}
# Set resolution 
res.used <- 1

tiss <- FindClusters(object = tiss, reduction.type = "pca", dims.use = 1:n.pcs, 
    resolution = res.used, print.output=FALSE, save.SNN = TRUE)

# If cells are too spread out, you can raise the perplexity. If you have few cells, try a lower perplexity (but never less than 10).
tiss <- RunTSNE(object = tiss, dims.use = 1:n.pcs, seed.use = 10, perplexity=15)

TSNEPlot(object = tiss, do.label = T)
TSNEPlot(tiss, group.by='vh_gene')
TSNEPlot(tiss, group.by='jh_gene')
TSNEPlot(tiss, group.by="Phase")
```


Check expression of genes of interset.

```{r, echo=FALSE}
genes_to_check = c('CD19',  'B2M', 'CD74')

FeaturePlot(tiss, genes_to_check, pt.size = 1, nCol = 3)
```

```{r}
VlnPlot(tiss, genes_to_check)
RidgePlot(tiss, genes_to_check)
```
Dotplots let you see the intensity of exppression and the fraction of cells expressing for each of your genes of interest.

```{r, echo=FALSE, fig.height=4, fig.width=8}
# To change the y-axis to show raw counts, add use.raw = T.
DotPlot(tiss, genes_to_check, plot.legend = T)
```
Show relationships between clusters

```{r}
BuildClusterTree(tiss)
```



How big are the clusters?
```{r}
table(tiss@ident)
```



<!-- Which markers identify a specific cluster? -->

<!-- ```{r} -->
<!-- clust.markers <- FindMarkers(object = tiss, ident.1 = 0, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25) -->
<!-- DotPlot(tiss, genes.plot = rownames(clust.markers)[1:20], plot.legend = T) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- print(x = head(x= clust.markers, n = 10)) -->
<!-- ``` -->

You can also compute all markers for all clusters at once. This may take some time.

```{r}
tiss.markers.pca <- suppressWarnings(FindAllMarkers(object = tiss, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25, print.bar=FALSE))
```

Display the top markers you computed above. Notice that all the adjusted p values are 1 --- nothing is truly significant!
```{r}
tiss.markers.pca %>% group_by(cluster) %>% top_n(25, avg_logFC)
```


```{r, fig.height=12, fig.width=8}
top.tiss.markers.pca = tiss.markers.pca %>% group_by(cluster) %>% top_n(-10, avg_logFC)
top.tiss.markers.pca.genes = top.tiss.markers.pca$gene

FeaturePlot(tiss, top.tiss.markers.pca.genes)
```


```{r, fig.height=12, fig.width=8}
RidgePlot(tiss, top.tiss.markers.pca.genes)
```

```{r, fig.width=16, fig.height=2}
DotPlot(tiss, top.tiss.markers.pca.genes)
```



# Do the same thing but for ICA

Save PCA clusters

```{r}
tiss@meta.data['pca.cluster.ids'] = tiss@ident

ICHeatmap(tiss, ic.use=1:6)
```
```{r}
DimElbowPlot(tiss, reduction.type = 'ica')
```
Use the number of Independent components just before it plateaus

```{r}
n.ics = 4

res.used <- 1

tiss <- FindClusters(object = tiss, reduction.type = "ica", dims.use = 1:n.ics, 
    resolution = res.used, print.output=FALSE, save.SNN = TRUE)

tiss <- RunTSNE(object = tiss, dims.use = 1:n.ics, seed.use = 10, perplexity=15, reduction.use = 'ica')
TSNEPlot(object = tiss, do.label = T)
TSNEPlot(tiss, group.by='vh_gene')
TSNEPlot(tiss, group.by='jh_gene')
TSNEPlot(tiss, group.by="Phase")
```

You can also compute all markers for all clusters at once. This may take some time.

```{r}
tiss.markers.ica <- suppressWarnings(FindAllMarkers(object = tiss, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25, 
                                   print.bar = FALSE))
```

Display the top markers you computed above. All the adjuted p values are 1 .. nothing is significantly differentially expressed!
```{r}
tiss.markers.ica %>% group_by(cluster) %>% top_n(25, avg_logFC)
```


```{r, fig.height=12, fig.width=8}
top.tiss.markers.ica = tiss.markers.ica %>% group_by(cluster) %>% top_n(-6, avg_logFC)
top.tiss.markers.ica.genes = top.tiss.markers.ica$gene

FeaturePlot(tiss, top.tiss.markers.ica.genes)
```

```{r, fig.height=12, fig.width=8}
RidgePlot(tiss, top.tiss.markers.ica.genes)
```


```{r, fig.width=16, fig.height=2}
DotPlot(tiss, top.tiss.markers.ica.genes)
```





# Save the Robject for later
When you save the annotated tissue, please give it a name.

```{r}
filename = here('memory-b-h1n1.Robj')
print(filename)
save(tiss, file=filename)
```

```{r}
# To reload a saved object
# load(file=filename)
```

